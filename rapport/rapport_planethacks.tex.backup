\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{algorithm,algpseudocode}
\usepackage{default}
\usepackage{xcolor}
\usepackage[francais]{babel}
\usepackage[top=3cm,bottom=3cm,right=3cm,left=3cm]{geometry}

\begin{document}

\author{LIMBALLE Pierre - PEREZ Quentin}
\title{Méthodes et Outils pour la Programmation\\% 
Mini Projet 2015}
\definecolor{primary}{RGB}{37,72,124}
\definecolor{secondary}{RGB}{253,250,200}

    
%\addtobeamertemplate{footline}{\insertframenumber/\inserttotalframenumber\\}
 %\addtobeamertemplate{sidebar bottom}{\insertframenumber}
\makeatletter
  \begin{titlepage}
  \centering
      {\LARGE \textbf{LIMBALLE Pierre - PEREZ Quentin}}\\
      UFR-ST - Licence informatique 3ème année\\Groupe TP 2B\\
    \vspace{2cm}
      {\LARGE \@date\\}
    \vspace{1cm}
        \includegraphics[width=0.3\textwidth]{java.png}\\
    \vspace{1em}
       {\LARGE \textbf{\@title}\\
    \vspace{1em}
       Rapport\\} 
    \vspace{2em}
    \vspace{1cm}
        \includegraphics[width=0.7\textwidth]{ufrst.jpg}\\
    \vspace{1.5cm}
      {Contacts : \href{mailto:pierre.limballe@edu.univ-fcomte.fr}{pierre.limballe@edu.univ-fcomte.fr}, \href{mailto:quentin.perez@edu.univ-fcomte.fr}{quentin.perez@edu.univ-fcomte.fr}\\Professeurs : GREFFIER Françoise, BONNEVILLE François}
    \vfill
        %\includegraphics[width=0.7\textwidth]{radare.png}\\
  \end{titlepage}
\makeatother

\newpage
\tableofcontents
\newpage

\section{Sujet}
\subsection{Contexte}
Dans le cadre du module: Méthodes et Outils pour la Programmation (MOP) la réalisation d'un projet nous a été demandé afin de mettre
en application les connaissances théoriques acquisent tout au long du semestre 5. \\
La conception de l'application a pour objectifs:
\begin{itemize}
  \item l'utilisation du langage de programmation Java en orienté objets
  \item l'application du paradigme MVC (Modèle - Vue - Contrôleur)
  \item l'approche du travail collaboratif par l'utilisation de logiciels de gestion de versions
  \item la manipulation d'éléments graphiques de la bibliothèque graphique Java Swing
\end{itemize}

\subsection{But de l'application}
La finalité de ce projet est la conception Java une application qui réalise une animation graphique en 2D 
représentant un ensemble de planètes et leurs satellites en orbite autour d'une ou plusieurs étoiles.
L'utilisateur doit disposer des fonctionnalités suivantes:
\begin{itemize}
  \item l'ajout et la suppression d'astres (étoiles ou satellites) dans l'application
  \item l'affichage des astres dans une fenetre graphique animée
  \item la possibilité de sauvegarder un système planétaire 
\end{itemize}
La contrainte d'ergonomie est également importante quant à l'utilisation du logiciel.

\newpage
\section{Conception}
\subsection{Introduction}
Planethacks est le nom choisi pour l'application. Du fait d'un travail en binôme, l'utilisation
d'un logiciel de gestion de version fut priviligiée. Nous avons pour cela utilisé Git, en lien avec le serveur d'hébergement \href{https://github.com}{GitHub} (sources GitHub de Planethacks: \url{https://github.com/qperez/planetacks}). 
\begin{center}
  $\includegraphics[scale=0.3]{git.png}$
\end{center}


L'IDE (\textit{Internal Development Environement}) IntelliJ IDEA fut utilisé durant toute la phase de développement et de tests et ce afin 
d'accélérer et faciliter le développement de l'application ainsi que son déboguage.\\
\begin{center}
  $\includegraphics[scale=0.3]{idea.png}$
\end{center}

\subsection{Structures de données au sein de l'application}
La définition de classes permettant de structurer les données de notre programme fut la première étape de conception. Ainsi 3 classes 
nous permettent de modéliser un astre:
\begin{itemize}
  \item Astre (classe abstraite)
  \item Etoile
  \item Satellite
\end{itemize}

Planethacks repose sur une conception basée sur le paradigme MVC. Ce paradigme impose l'utilisation à minima de 3 classes (Modèle - Vue - Contrôleur) permettant de
séparer les données de l'affichage et des interactions utilisateur. \\ 
Dans un soucis de respect du modèle MVC nous disposons donc des classes suivantes:
\begin{itemize}
  \item Fenetre
  \item Modele
  \item Controleur (classe abstraite)
  \item ControleurMenu
  \item AffichageAstres
\end{itemize}

Afin de réaliser la fonctionnalité de sauvegarde une classe spécifique contenant les outils nécessaires fut créée: XMLTools. \\
Le point d'entré de l'application est assuré par la classe Appli.

\subsubsection{Modélisation d'un astre (Etoile ou Satellite)}
Le diagramme UML ci-dessous représente la modélisation choisie pour un astre:
\begin{center}
  $\includegraphics[scale=0.4]{classes_astre.png}$
\end{center}
Les méthodes \textit{calculPositionSatelliteX(float)} et \textit{calculPositionSatelliteX(float)} présentes dans la classe Satellite permettent
de calculer la position en X et en Y du Satellite en fonction du temps. La méthode \textit{ajouterSatellite(Satellite)} permet de mettre en orbite un satellite autour d'un astre. Enfin, la méthode \textit{supprimer(Modele)} permet de supprimer récursivement un astre et ses satellites à partir du modèle donné.

\subsection{Structure générale de l'application}

\subsubsection{Emplacement des fichiers}
Nous avons utilisé une structure de fichiers qui nous parraissait être la plus simple et la meilleure pour le fonctionnement de l'application. Ci-dessous, une représentation de l'arborescence :\\
\begin{center}
  $\includegraphics[scale=0.7]{arbo.png}$
\end{center}

Nous pouvons retrouver les dossiers de production suivants, dans lesquels nous manipulions directement les fichiers :
\begin{itemize}
 \item \begin{verbatim}src\end{verbatim} $\rightarrow$ dossier des sources (.java)
 \item \begin{verbatim}ressources\end{verbatim} $\rightarrow$ dossier des différents fichiers image ou audio
 \begin{itemize}
  \item \begin{verbatim}img\end{verbatim} $\rightarrow$ dossier contenant toutes les images du projet
  \begin{itemize}
   \item \begin{verbatim}appli\end{verbatim} $\rightarrow$ dossier des images de l'application en général
   \item \begin{verbatim}astres\end{verbatim} $\rightarrow$ dossier des images des astres (.png)
  \end{itemize}
  \item \begin{verbatim}sounds\end{verbatim} $\rightarrow$ dossier contenant tous les sons du projet
 \end{itemize}
 \item \begin{verbatim}rapport\end{verbatim} $\rightarrow$ dossier contenant les fichiers permettant de réaliser ce rapport (fichiers \LaTeX)
\end{itemize}
\vspace{0.5cm}
Mais également des dossiers dont le contenu est généré automatiquement :
\begin{itemize}
 \item \begin{verbatim}out\end{verbatim} $\rightarrow$ dossier des fichiers java compilés (.class)
 \item \begin{verbatim}save\end{verbatim} $\rightarrow$ dossier des fichiers de sauvegarde générés par l'application (.xml)
 \item \begin{verbatim}documentation\end{verbatim} $\rightarrow$ dossier contenant la documentation du projet (.html)
 \item \begin{verbatim}.idea\end{verbatim} $\rightarrow$ dossier contenant les fichiers de configuration du logiciel \textit{IntelliJ IDEA}
\end{itemize}
\vspace{0.5cm}
Ainsi que des fichiers seuls :
\begin{itemize}
 \item \begin{verbatim}.gitignore\end{verbatim} $\rightarrow$ fichier permettant d'ignorer l'envoi de fichiers sur GitHub (ex : dossier \textit{out})
 \item \begin{verbatim}README.md\end{verbatim} $\rightarrow$ fichier MarkDown de présentation du projet sur GitHub
 \item \begin{verbatim}planetacks.iml\end{verbatim} $\rightarrow$ fichier de configuration du projet pour \textit{IntelliJ IDEA}
\end{itemize}

\subsubsection{Architecture MVC}
\begin{center}
  $\includegraphics[scale=0.4]{classes_mvc.png}$
\end{center}

Comme dit précédemment, nous avons utilisé le paradigme MVC afin de faciliter le développement. Dans cette architecture, nous pouvons retrouver 3 principales classes qui sont les représentantes du modèle MVC : 
\begin{itemize}
 \item \textit{Modele} abstraite implémentant la classe \textit{ActionListener}
 \item \textit{Fenetre} étendue de la classe \textit{JFrame}
 \item \textit{Controleur}
\end{itemize}

La classe \textit{Modele} nous permet de gérer la liste des astres, comme par exemple ajouter une Etoile, ainsi que l'enregistrement et la restauration d'un système planétaire. Plus généralement, elle est le modèle des données de l'application.

La class \textit{Fenetre} s'occupe de tout ce qui touche à l'interface utilisateur, sauf la gestion différents pop-up que nous verrons dans la classe \textit{FenetreDialogue}. Elle regroupe la présentation et le design de l'application, comme le menu, l'image de fond...

La classe \textit{Controleur} quant à elle, permet de faire le lien entre les deux classes précédente. Elle permet donc la gestion des événements, ainsi que la synchronisation entre les données et l'affichage.

Ici, le contrôleur connait la vue et le modèle, la vue ne connait que le modèle, tandis que le modèle n'a pas d'informations sur les deux autres.

La classe \textit{ControleurMenu} ne contrôle uniquement le menu et les actions qu'il peut avoir. Elle est étendue de la classe \textit{Controleur}.

La classe \textit{FenetreDialogue} prend en compte toutes les interactions avec l'utilisateur, comme l'ajout d'un astre, ou encore la sauvegarde d'un système planétaire.

La classe \textit{AffichageAstres} étendue de la classe \textit{Thread}, permet de lancer une boucle infinie pour desssiner les astres sur la fenêtre principale.

La classe \textit{Audio} nous permet de gérer plus facilement la lancement et l'arrêt du son de l'application.

\subsection{Les algorithmes intéressants}

\begin{algorithm}
\caption{méthode repaint de la classe Fenetre}
\begin{algorithmic}
\Function{repaint}{t temps}
\State Supprimer l'ensemble des composants graphique du JPanel
\For{chaque Etoile $e$ de la liste d'étoiles du Modele}
    \State $jlabastre\gets$ nouveau JLabel avec l'image de $e$
    \State Afficher $jlabastre$ en fonction de la position $X_{e}$ et $Y_{e}$
    \State Ajouter le $jlabastre$ au JPanel
    \State Appel de la fonction $repaintSatellite$ avec $e.getListeSatellite()$ et $t$
\EndFor
\State Appel de la méthode $repaint()$ sur le JPanel
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{repaintSatellite}{l listeSatellite, t temps}
\For{chaque Satellite $s$ de la liste des satellites $l$}
  \State $jlabsat\gets$ nouveau JLabel avec l'image de $s$
  \State Afficher $jlabsat$ en fonction de $s.calculPositionSatelliteX(t)$ et $s.calculPositionSatelliteY(t)$
  \State Ajouter le $jlabsat$ au JPanel
  \State Appel récursif de $repaintSatellite$
\EndFor
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Points intéressants et supplémentaires du programme}
Afin de ne pas rester dans la banalité, avons décidé de créer un "mode" \textit{StarWars}. 

Tout d'abord, il a fallu recréer des nouvelles planètes tirées de la saga, comme \textit{Tatooine}, \textit{Naboo}, \textit{Jakku}, l'\textit{étoile noire} ainsi qu'un \textit{fighter} (vaisseau côté obscur de la force) ou encore le \textit{Faucon Millenium} d'Han Solo. Ceci nous a fait découvrir l'utilisation de zones transparentes dans une image PNG, ainsi que le logiciel Gimp que nous n'avions pas utilisé dans notre formation jusqu'à présent.

De plus, nous avons implémenté la gestion du son, que l'on peut activer ou désactiver grâce à un menu prévu pour. Celui-ci s'active automatiquement lorsque l'on charge la sauvegarde de l'environnement \textit{StarWars}, avec le thème original des 7 films accompagné de plusieurs bruitages célèbres. L'intégration de son dans une application était inconnue pour nous auparavant, c'est pourquoi nous avons décidé de l'ajouter à notre projet pour la découvrir.

\subsection{Tests}
Les tests ainsi que la documentation ont été réalisés tout au long du développement. Ceci nous a permis de pouvoir déboguer facilement et de ne pas perdre de temps dans la production à cause d'erreurs de programmation. Les outils utilisés pour la construction du projet nous ont aussi facilité les tests. 

En effet, \textit{IntelliJ IDEA} propose des fonctionnalités permettant d'éviter un grand nombre d'erreurs (auto-complétion inter-classes, renommage des variables et fonctions sur tout le projet, messages explicites lors d'une erreur...) et de passer moins de temps sur des problèmes de syntaxe. 

De plus, grâce au gestionnaire de version GitHub, il est aisé de retrouver les modifications apportées à un fichier, et pourquoi elles ont été faites. Ici encore, cela permet de gagner du temps et de pouvoir retrouver un projet fonctionnel même après avoir rencontré un problème lourd lors du développement. 

Pour finir, ces deux logiciels fonctionnent l'un avec l'autre, ce qui rend la construction du projet très confortable.
\\

Une phase de tests plus conséquente a été réalisée à la fin du projet, pour trouver d'éventuels conflits entre les différentes fonctionnalités et au fur et à mesure du déroulement du programme.

\newpage
\section{Conclusion}
\subsection{Bilan}
Nous avons pu répondre aux différents points demandés à savoir :
\begin{itemize}
 \item Créer un astre qui est ajouté dynamiquement à l'ensemble des astres de l'appli
 \item Supprimer un astre dynamiquement de l'application
 \item Enregistrer sur le disque un fichier comprenant une étoile et ses satellites
 \item Ouvrir un fichier enregistré comprenant une étoile et ses satellites
\end{itemize}

Toutes les classes ont été testées afin de limiter au maximum les bogues et les problèmes lors de l'éxécution.


\subsection{Les acquis}
Les acquis au cours de ce projet ont été divers. Premièrement, nous avons approfondi nos connaissances sur le MVC ainsi que sur la manière de l'utiliser. Des problèmes de conception et nottamment d'accessibilité des variables ont été rencontrés et par la suite corrigés, ce qui a été formatteur.
\\

Par le fait d'avoir implémenté un mode \textit{StarWars}, nous avons pu découvrir plusieurs technologies que nous ne savions pas utiliser. La première, la retouche photo qui a été effectuée avec \textit{Gimp} (logiciel gratuit et libre) afin de créer différentes planètes à partir d'images, en ajoutant un filtre de transparence. La deuxième, la prise en charge de la musique dans l'application a été amusante à mettre en place, d'autant plus que nous ne l'avions jamais fait auparavant lors de projets diverses.
\\

Le travail en groupe n'était pas une déouverte, mais nous avions pu confirmer notre méthode pour parvenir à fournir un travail efficace avec le moins de problèmes possibles.

\subsection{Améliorations apportées}

\subsection{Améliorations futures}

\end{document}
